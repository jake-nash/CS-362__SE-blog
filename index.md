# SE blog

 
 
 

#### HW0: Introduction

Hi, I'm Jacob Nash, a junior at CofC. This is my second attempt at getting a degree, so far it's going better than the first try. I'm enjoying learning new things again. I work as a math tutor, so if you need help in any math class feel free to reach out; my email is nashjr@g.cofc.edu, and my phone is (843) 847-1338.





#### HW1: Chapter 1


_1.3:  What are the four important attributes that all professional software should possess? Suggest four other attributes that may sometimes be significant._

Acceptability, Dependability/Security, Efficiency, and Maintainability. I also think that all software should be economically feasibile (can be made within a pre-defined budget), ethically sound, unintrusive (concerning users' private information), and, to some extent, future-proof (this is obviously not guaranteed, but software should continue to receive support/maintainence while it is still in use).

_1.8:  Discuss whether professional software engineers should be licensed in the same way as doctors or lawyers._

I think that it would be very difficult to create some license that would certify that a software engineer is qualified to work on software; as the book mentions repeatedly throughout chapter 1, software can take on many different forms, each with their own set of necessities and priorities. The license would either be far too specific, requiring all software engineers to be proficient in engineering all possible types of software, or it would be so broad in scope that licesure would not convey any sense of certification because of the lack of specific skill/knowledge checks. 

_1.9:  For each of the clauses in the ACM/IEEE Code of Ethics shown in Figure 1.4, propose an appropriate example that illustrates that clause._

PUBLIC - a software engineer should not create software to exploit users' personal data, as this is in no way to the public's interest.
CLIENT AND EMPLOYER - a software engineer should strive to create software that meets or exceeds their client's/employer's specifications.
PRODUCT - software engineers should take pride in their work and ensure that their software is (at least) acceptable, dependable/secure, efficient, and maintainable.
JUDGMENT - software engineers must use thier good judgement to ensure the integrity of their efforts and of the finished product.
MANAGEMENT - anyone managing software engineers should be sure to promote (and themselves follow) professional and ethical work standards.
PROFESSION - software engineers should consider how their actions reflect on the practice of software engineering, and strive to uphold the professionalism of the job.
COLLEAGUES - all software engineers should treat colleagues as equals.
SELF - a software engineer should be dedicated to improving their skills and knowledge of the craft for as long as they practice it, while holding themselves to the ethical standards put forth in the ACM/IEEE-CS code of ethics.

_1.10: To help counter terrorism, many countries are planning or have developed computer systems that track large numbers of their citizens and their actions. Clearly, this has privacy implications. Discuss the ethics of working on the development of this type of system._

In many ways, creating/maintaining software like this (or in practically any military use) would require the individual to ensure that they follow their own personal ethical values first and foremost. Everyone's personal ethics on military action (even in the "preventative" sense) differ; their is no common answer to the ethicality of such actions. I feel that it would be the responsibility of all parties involved to regularly and often check the ethicality of what they are working on, in order to be sure that no lines have been crossed; any software engineers involved in such a project should know where that line is, for them personally, and respect it.





### HW2: Reflections on Software Engineering Practices

I think that the biggest commonality between all three of the readings was that software development has become more and more complex through the years, and shows no signs of becoming simpler due to ever-increasing and ever-changing demands of software. The first article (“No Silver Bullet”) surprised me as a reader, because I would have thought that a computer science article from 1986 couldn’t possibly be relevant today—in some ways, I do feel that it was obsolete (the specific technologies and methodologies for designing and coding software have in some ways changed), but at the same time some of the information was still relevant. I would say the two most interesting ideas of this article were the ideas that (a) software is essentially complex, and there is no way to address that inherent complexity, and (b) that software is essentially abstract, and difficult/impossible to model graphically. The author gave no proof that either of these traits are in fact essential to software, and I’m not sure that I agree with those assumptions; yes, graphical depiction of many concepts is difficult, but I feel that is no more the case than for other sciences, and yes, software is typically quite complex—but is it inherently so? I would like to see some sort of demonstration (not even a formal proof) of these ideas, and I think it would be interesting to contact this author today to ask his thoughts now on this article he wrote in 1986. The second article, which was really more of an advice column, didn’t really offer much new info to me. It addressed specific problems from two individuals, and I think that it was relatively good advice, but I don’t think it was very generalizable to all of software engineering. My most useful takeaway from this article is that people should always be comfortable to ask questions, and that doing so indicates a desire to improve; I also liked the idea that computer science is indeed a science, and therefore the scientific model is applicable. The last article, about Google’s giant codebase, was very interesting to me and also made me think about some aspects of software engineering that I haven’t before. Since I am now learning about Git and VC software in general, I was surprised to read that Google, one of the largest software companies on the planet, does not use Git or some other distributed VC; the reasons put forth in the article now make sense, but I was still surprised to read that after just learning about the advantages of Git. The enormity and complexity of managing Google’s codebase was impressive to read about, and also made me consider the idea of software designed and used specifically for managing other software—this sort of “meta” software development sounded useful, certainly, but also I think very difficult. To some extent I was already aware of this idea (essentially, an OS is a piece of software meant to manage the flow of control between the user and different softwares); but the idea of creating a software (eg Piper) so that it could be used at such a large scale, and then on top of that creating a software (eg Clipper) to help manage and control and simplify the other software that had just been created, seems very complex to me, not the concept but the actual practice of it.




(hw3)
